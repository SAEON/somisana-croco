name: run the operational workflow on a local server

on:
  workflow_call:
    inputs:
      RUN_DATE:
        description: 'time of T0 of the model run in format YYYYMMDD_HH - defined dynamically in run_ops.yml'
        required: true
        type: string
      BRANCH_REF:
        description: 'what branch are we on - defined dynamically in run_ops.yml'
        required: true
        type: string
      RUNNER_NAME:
        description: 'specify the runner name to determine what server we are running on'
        required: true
        type: string

jobs:

  pull-latest-docker-images:
    runs-on: ${{ inputs.RUNNER_NAME }}
    steps:
      - name: pull latest somisana-download docker image to server
        run: |
          docker pull ghcr.io/saeon/somisana-download_main:latest
      - name: pull latest somisana-croco docker image to server
        run: |
          docker pull ghcr.io/saeon/somisana-croco_cli_${{ inputs.BRANCH_REF }}:latest

  checkout-source-code:
    runs-on: ${{ inputs.RUNNER_NAME }}
    steps:
      - name: pull latest somisana-croco code to server
        run: |
          cd /home/somisana/code/somisana-croco
          git fetch origin
          if git show-ref --verify --quiet refs/heads/${{ inputs.BRANCH_REF }}; then
            git checkout ${{ inputs.BRANCH_REF }}
          else
            git checkout -b ${{ inputs.BRANCH_REF }} origin/${{ inputs.BRANCH_REF }}
          fi
          git pull

  cleanup:
    uses: ./.github/workflows/cleanup.yml 
    with:
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
  
  # prepare croco config dirs for each domain
  prep_domains:
    strategy:
      matrix:
        # running as a matrix strategy allows us to prepare different domains in parallel inside a single job
        domain: ['sa_southeast_01','sa_west_02']
    uses: ./.github/workflows/prep_domain.yml
    with:
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      MODEL: croco_v1.3.1
      DOMAIN: ${{ matrix.domain }}
      COMP: C06
      # in future we may want to use different compile options for each domain
      # one way of handling that may be to add the compile option to each string in the domain variable under the matrix strategy
      # and then tease out the domain and compile option inside prep_domain.yml

  # download the surface data we'll need to force the models
  download_surface:
    needs: [pull-latest-docker-images]
    uses: ./.github/workflows/download_surface.yml
    with:
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      HDAYS: 5
      FDAYS: 5
    secrets: inherit
  
  # download the OGCM data we'll need to force the models
  download_mercator:
    needs: [pull-latest-docker-images]
    uses: ./.github/workflows/download_mercator.yml
    with:
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      HDAYS: 5
      FDAYS: 5
    secrets: inherit

  download_hycom:
    needs: [pull-latest-docker-images]
    uses: ./.github/workflows/download_hycom.yml
    with:
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      HDAYS: 5
      FDAYS: 5
    secrets: inherit

  # prepare tidal forcing for each domain
  make_tide_frc:
    needs: [prep_domains]
    strategy:
      matrix:
        # running as a matrix strategy allows us to prepare different domains in parallel inside a single job
        domain: ['sa_southeast_01','sa_west_02']
    uses: ./.github/workflows/make_tides.yml  # Path to your reusable workflow
    with:
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      MODEL: croco_v1.3.1
      DOMAIN: ${{ matrix.domain }}
      TIDE_FRC: TPXO10
      HDAYS: 5
  
  # run the model, do the postprocessing, archive the output
  # 
  # we must ensure that run_all_domains.yml must use less than 120 processors in parallel - this is our limit
  #
  # we've also found that you can't run 4 domains in parallel, even if they use less than 120 processors in total 
  # the runs slow down hugely, so it's better to use more processors per domain and run them in series

  run_mercator_domains:
    needs: [prep_domains,download_surface,download_mercator,make_tide_frc]
    uses: ./.github/workflows/run_all_domains.yml
    with:
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      OGCM: MERCATOR
      SAWS_OK: ${{ needs.download_surface.outputs.SAWS_OK }}
    secrets: inherit

  run_hycom_domains:
    needs: [prep_domains,download_surface,download_hycom,make_tide_frc,run_mercator_domains] 
    if: ${{ always() }} # execute even if there was an error with the mercator runs
    uses: ./.github/workflows/run_all_domains.yml
    with:
      RUN_DATE: ${{ inputs.RUN_DATE }}
      BRANCH_REF: ${{ inputs.BRANCH_REF }}
      RUNNER_NAME: ${{ inputs.RUNNER_NAME }}
      OGCM: HYCOM
      SAWS_OK: ${{ needs.download_surface.outputs.SAWS_OK }}
    secrets: inherit
