name: Run SOMISANA forecast models on MIMS

on:
  # commented for now
  #schedule:
    # Runs every 6 hours
    #  - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      run_date:
        description: 'Date and time for T0 for the run in format YYYYMMDD_HH'
        required: false
        default: ''
        type: string
      hdays:
        description: 'number of hindcast days (integer) from T0'
        required: true
        default: 5
        type: string
      fdays:
        description: 'number of forecast days (interger) from T0'
        required: true
        default: 5
        type: string
      build_images:
        description: 'Run the image builds?'
        required: true
        default: 'true'
        type: boolean

jobs:
  build_images:
    if: ${{ github.event.inputs.build_images == 'true' }}  # Conditional execution (saves time when testing something else and we don't want to build it every time)
    strategy:
      matrix: # the 'matrix' strategy allows us to build all three docker images in parallel using the same reusable workflow
        image_id: ['cli', 'run', 'matlab']
    uses: ./.github/workflows/build_images.yml  # Path to your reusable workflow
    with:
      IMAGE_ID: ${{ matrix.image_id }}

  # start by setting some environment variables
  envs:
    runs-on: ubuntu-latest
    outputs:
      BRANCH_REF: ${{ steps.BRANCH_REF.outputs.value }}
      RUN_DATE: ${{ steps.calculate_date.outputs.value }}
    steps:
      - name: Calculate run_date
        id: calculate_date
        run: |
          input_run_date=${{ github.event.inputs.run_date || 'unspecified' }}
          if [[ ${{ github.event_name }} == 'workflow_dispatch' && ${input_run_date} != 'unspecified' ]]
          then
            run_date="${{ github.event.inputs.run_date }}"  # Use provided run_date
          else
            # automatically set the run_date by finding the nearest 6 hourly time stamp in the past
            # Get the current time in UTC
            current_time=$(date -u +'%Y%m%d_%H')
            # Extract the hour and calculate the nearest multiple of 6 in the past
            hour=$(echo ${current_time:9:2} | awk '{print int($1 - ($1%6))}')
            # Correct hour formatting (ensure leading zero)
            hour=$(printf "%02d" $hour)
            # Assemble the run_date
            run_date=$(echo ${current_time:0:8}_${hour})            
          fi
          echo "value=$run_date" >> $GITHUB_OUTPUT
          
      # Dynamically set the branch ref to the currently executing branch
      - name: Set the BRANCH_REF
        id: BRANCH_REF
        run: |
          echo "value=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT
  
  # everything below here runs using the `mims1` self-hosted runner
  # This is the `computecroco01` server with 128 cpu's and 256 G ram, dedictated to running SOMISANA's operational models
  # It is possible that we may want to use an additional modelling server (which will be a separate node)
  # In that event, we could put all the code below here in a new reusable workflow called run_ops_mims1.yml
  # And then set up another one called run_ops_mims2.yml set up in the same way but obviously running different models/domains
  # (note you'll also have to include another `git pull` command at the end of build_images.yml to make sure the latest images are available on the new server) 

  # download all the data we'll need to force the models
  # no need to provide any model specific inputs as we hard code the extent to cover the whole EEZ
  get_forcing:
    needs: [envs, build_images]
    if: ${{ always() }}  # Always run even if build_images is not executed (but it'll wait for build_images if it is)
    uses: ./.github/workflows/get_forcing.yml  # Path to your reusable workflow
    with:
      RUNNER_NAME: mims1
      RUN_DATE: ${{ needs.envs.outputs.RUN_DATE }}
      BRANCH_REF: ${{ needs.envs.outputs.BRANCH_REF }}
      HDAYS: ${{ inputs.hdays }}
      FDAYS: ${{ inputs.fdays }}
    secrets: inherit

  # prep the run directory 
  prep_run_dirs:
    needs: [envs, build_images]
    if: ${{ always() }}  # Always run even if build_images is not executed (but it'll wait for build_images if it is)
    strategy:
      matrix:
        # matrix strategy allows us to setup multiple domains in parallel using the same reusable workflow
        # for now it's only setting up one domain, so we're not really using the matrix strategy yet, but this will come 
        domain: ['swcape_02']
    uses: ./.github/workflows/prep_run_dir.yml  # Path to your reusable workflow
    with:
      RUN_DATE: ${{ needs.envs.outputs.RUN_DATE }}
      BRANCH_REF: ${{ needs.envs.outputs.BRANCH_REF }}
      RUNNER_NAME: mims1
      MODEL: croco_v1.3.1
      DOMAIN: ${{ matrix.domain }}
  
  # generate croco forcing files
  prep_croco_forcing:
    needs: [envs,prep_run_dirs,get_forcing]
    strategy:
      matrix:
        domain: ['swcape_02']
        blk: ['GFS']
        frc: ['']
        ogcm: ['MERCATOR']
    uses: ./.github/workflows/prep_croco_forcing.yml  # Path to your reusable workflow
    with:
      RUN_DATE: ${{ needs.envs.outputs.RUN_DATE }}
      BRANCH_REF: ${{ needs.envs.outputs.BRANCH_REF }}
      RUNNER_NAME: mims1
      MODEL: croco_v1.3.1
      DOMAIN: ${{ matrix.domain }}
      COMP: C01
      INP: I01
      BLK: ${{ matrix.blk }}
      FRC: ${{ matrix.frc }}
      OGCM: ${{ matrix.ogcm }}
      HDAYS: ${{ inputs.hdays }}

#  compile_models:
#    needs: [prep_forcing]
#    strategy:
#      matrix:
#        domain: ['swcape_02']
#        model: ['croco_v1.3.1']
#        compile: ['C01']
#        mpi_num_x: [3]
#        mpi_num_y: [10]
#        blk: ['GFS']
#        frc: ['']
#        ogcm: ['MECATOR']
#        infile: ['I99']
#    uses: ./.github/workflows/run_models.yml  # Path to your reusable workflow
#    with:
#      DOMAIN: ${{ matrix.domain }}
#      MODEL: ${{ matrix.model }}
#      COMPILE: ${{ matrix.compile }}
#      MPI_NUM_X: ${{ matrix.mpi_num_x }}
#      MPI_NUM_Y: ${{ matrix.mpi_num_y }}
#      BLK: ${{ matrix.blk }}
#      FRC: ${{ matrix.frc }}
#      OGCM: ${{ matrix.ogcm }}
#      INFILE: ${{ matrix.infile }}
#
#  run_models:
#    needs: [prep_forcing_1]
#    strategy:
#      matrix:
#        domain: ['swcape_02']
#        model: ['croco_v1.3.1']
#        compile: ['C01']
#        mpi_num_x: [3]
#        mpi_num_y: [10]
#        blk: ['GFS']
#        frc: ['']
#        ogcm: ['MECATOR']
#        infile: ['I99']
#    uses: ./.github/workflows/run_models.yml  # Path to your reusable workflow
#    with:
#      DOMAIN: ${{ matrix.domain }}
#      MODEL: ${{ matrix.model }}
#      COMPILE: ${{ matrix.compile }}
#      MPI_NUM_X: ${{ matrix.mpi_num_x }}
#      MPI_NUM_Y: ${{ matrix.mpi_num_y }}
#      BLK: ${{ matrix.blk }}
#      FRC: ${{ matrix.frc }}
#      OGCM: ${{ matrix.ogcm }}
#      INFILE: ${{ matrix.infile }}
